---
title: "Transcriptomics and the analysis of RNA-Seq data"
author: 'Tianru Zhang (PID: A15432834)'
date: "11/16/2021"
output: pdf_document
---

#1. Bioconductor and DESeq2 setup
```{r}

#install.packages("BiocManager")
#BiocManager::install()
# For this class, you'll also need DESeq2:
#BiocManager::install("DESeq2")


library(BiocManager)
library(DESeq2)

```
#2. Import countData and colData

```{r}
#use the read.csv() function to read these count data and metadata files.

counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <-  read.csv("airway_metadata.csv")
```


```{r}
head(counts)
head(metadata)
```

>Q1. How many genes are in this dataset? 
38694

```{r}
dim(counts)
```
>Q2. How many ‘control’ cell lines do we have?
4

```{r}
sum(metadata$dex=="control")


```




#3. Toy differential gene expression

First, need to extract all the control columns, then take tha row-wise mean to get the average count values for all gene in these 4 experiments.
```{r}
control <- metadata[metadata[,"dex"]=="control",]
control.counts <- counts[ ,control$id]
control.mean <- rowSums( control.counts )/4 
head(control.mean)
control.mean<-rowMeans(control.counts)
```

```{r}
library(dplyr)
control <- metadata %>% filter(dex=="control")
control.counts <- counts %>% select(control$id) 
control.mean <- rowSums(control.counts)/4
head(control.mean)
```
>Q3. How would you make the above code in either approach more robust?

By adding more samples in to the analysis.

>Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

```{r}
treated <- metadata[,"dex"]=="treated"
treated.counts <- counts[,treated]
head(treated.counts)
treated.mean <- rowMeans(treated.counts)

```

```{r}
meancounts <- data.frame(control.mean, treated.mean)
colSums(meancounts)
```

>Q5 (a). Create a scatter plot showing the mean of the treated samples against the mean of the control samples. 

```{r}
plot(meancounts[,1],meancounts[,2], xlab="Control", ylab="Treated")
```

>Q5 (b).Use the ggplot2 package to make this figure producing the plot below. What geom_?() function would you use for this plot? 
The geom_point() layer is used.

```{r}

library(ggplot2)
ggplot(meancounts)+
  aes(meancounts[,1],meancounts[,2])+
  labs(x="Control", y="Treated")+
  geom_point(alpha=0.4)
```
We can do a log transformation 

>Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this? 

log


```{r}
plot(meancounts[,1],meancounts[,2], xlab="Control", ylab="Treated", log="xy")
```
log 2 is often used in this field, because the interpretation would be easier 



```{r}
log2(10/10)
log2(40/10)
log2(5/10)
```
We see 0 values for no change and + values for increases and minus values for decreases. This nice property allows us to work with **log2()fold_change**

Add the log2 fold change to `meancounts`
```{r}
#make a new column to meancounts
meancounts$log2fc <- log2(meancounts[,"treated.mean"]/meancounts[,"control.mean"])
head(meancounts)
```
```{r}
head(meancounts[,1:2]==0)
```
```{r}
which(c(F,F,T,T))
#help("which")
```


Use the **which** function with the `TRUE` argument to get the columns and rows where true values are. (the zero counts!)

```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,"row"])
head(sort(to.rm))
#now remove the genes from meancounts dataframe

mycounts <- meancounts[-to.rm,]
head(mycounts)
```
>Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?
Answer: 1. arr.ind=TRUE argument will make which() to return both the row and column indices where there are TRUE values. In this case this will tell us which genes (rows) and samples (columns) have zero counts, so later on we can remove them.
2. unique() ensures that the rows are unique(because some rows and columns can have zeros at the same time and count twice)

The number of genes left? 21817

```{r}
nrow(mycounts)
```
```{r}
up.ind <- mycounts$log2fc > 2
down.ind <- mycounts$log2fc < (-2)
```


```{r}
sum(up.ind)
sum(down.ind)
```

>Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level? 
250

>Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level? 
367

>Q10. Do you trust these results? Why or why not?
NO. fold change can be large (e.g. >>two-fold up- or down-regulation) without being statistically significant. We need to decide the statsitical significance of the gene reagulations.



#4.DESeq 2 analysis
```{r}
library(DESeq2)
citation("DESeq2")
```
```{r}
dds <- DESeqDataSetFromMatrix(countData=counts, 
                              colData=metadata, 
                              design=~dex)
dds
```

```{r}
dds <- DESeq(dds)
dds
```
```{r}
res <- results(dds)
res
```


#Save results 
Write out the entire dataset, including genes that don't change significantly
```{r}
write.csv(res,file="allmyresults.csv")
```

```{r}
summary(res)
```
Focus on changes with a small p-value:
```{r}
res05 <- results(dds, alpha=0.05)
summary(res05)
```


```{r}
library("AnnotationDbi")
#BiocManager::install("org.Hs.eg.db")
library("org.Hs.eg.db")
```

#5 Adding annotation data

```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(res), # Our genenames
                     keytype="ENSEMBL",        # The format of our genenames
                     column="SYMBOL",          # The new format we want to add
                     multiVals="first")
head(res)

```




>Q11.Run the mapIds() function two more times to add the Entrez ID and UniProt accession and GENENAME as new columns called res$entrez, res$uniprot and res$genename.


```{r}
res$entrez <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

res$uniprot <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="UNIPROT",
                     keytype="ENSEMBL",
                     multiVals="first")

res$genename <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="GENENAME",
                     keytype="ENSEMBL",
                     multiVals="first")

head(res)
```

```{r}
ord <- order( res$padj )
#View(res[ord,])
head(res[ord,])
```




#6. Volcano plots


```{r}
plot(res$log2FoldChange, log(res$padj))

```

We can flip the p-value axis by by changing the sign of y axis


```{r}
plot( res$log2FoldChange,  -log(res$padj), 
      xlab="Log2(FoldChange)",
      ylab="-Log(P-value)")
```
To make this more useful we can add some guidelines (with the abline() function) and color (with a custom color vector) highlighting genes that have padj<0.05 and the absolute log2FoldChange>2.

```{r}
plot( res$log2FoldChange,  -log(res$padj), 
 ylab="-Log(P-value)", xlab="Log2(FoldChange)")

# Add some cut-off lines
abline(v=c(-2,2), col="darkgray", lty=2)
abline(h=-log(0.05), col="darkgray", lty=2)
```
To color the points we will setup a custom color vector indicating transcripts with large fold change and significant differences between conditions:

```{r}
#Setup our custom point color vector 
#add color to the points
mycols <- rep("gray", nrow(res))
#make the points red whose fold change is greater than 2
mycols[ abs(res$log2FoldChange) > 2 ]  <- "red" 

inds <- (res$padj < 0.01) & (abs(res$log2FoldChange) > 2 )
mycols[ inds ] <- "blue"

# Volcano plot with custom colors 
plot( res$log2FoldChange,  -log(res$padj), 
 col=mycols, ylab="-Log(P-value)", xlab="Log2(FoldChange)" )

# Cut-off lines
abline(v=c(-2,2), col="gray", lty=2)
abline(h=-log(0.1), col="gray", lty=2)
```




# add Annotation data for our genes
Need two bioconductor packages:
BiocManager::install("AnnotationDbi")

```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")


```



```{r}
columns(org.Hs.eg.db)
```
Use the map ID function to translate data between identifiers from diff datasets 
```{r}
res$symbol = mapIds(org.Hs.eg.db,
                    keys=row.names(res), #our gene names
                    keytype="ENSEMBL",     #the format of those genes
                    column="SYMBOL",
                    multiVals="first")


head(res, 10)
```
```{r}
#need to add ENTREZ ID as well

res$entrez <- mapIds(org.Hs.eg.db,
                     keys=row.names(res),
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")
head(res)
```


`

Let's make another volcano plot
**Enhanced Volcano** biopackage:

```{r}
library(EnhancedVolcano)

x <- as.data.frame(res)

EnhancedVolcano(x,
    lab = x$symbol,
    x = 'log2FoldChange',
    y = 'pvalue')
```




# 7 Pathway analysis 1
```{r}

library(pathview)
library(gage)
library(gageData)

data(kegg.sets.hs)

# Examine the first 2 pathways in this kegg set for humans
head(kegg.sets.hs, 2)


foldChange<-res$log2FoldChange
names(foldChange) <- res$entrez
```
```{r}
keggres<-gage(foldChange,gsets=kegg.sets.hs)
attributes(keggres)

# Look at the first three down (less) pathways
head(keggres$less, 3)
```
```{r}
pathview(gene.data=foldChange, pathway.id="hsa05310")
```

```{r}
# A different PDF based output of the same data
pathview(gene.data=foldChange, pathway.id="hsa05310", kegg.native=FALSE)
```
![](hsa05310.pathview.png)

>Q12 Plot the figures for the first 2 down regulated pathways


```{r}

pathview(gene.data=foldChange, pathway.id="hsa05332")
pathview(gene.data=foldChange, pathway.id="hsa04940")
```

![](hsa04940.pathview.png)
![](hsa05332.pathview.png)
